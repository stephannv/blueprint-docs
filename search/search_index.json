{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#whats-blueprint","title":"What's Blueprint?","text":"<p>Blueprint is a framework for writing reusable and testable HTML templates in plain Crystal, allowing an oriented object approach when building web views.</p> <pre><code>class Alert\n  include Blueprint::HTML\n\n  private def blueprint\n    div class: \"alert alert-success\" do\n      h4(class: \"alert-heading\") { \"Well done!\" }\n      span \"Nice message here\"\n    end\n  end\nend\n\nalert = Alert.new\nalert.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;div class=\"alert alert-success\"&gt;\n  &lt;h4 class=\"alert-heading\"&gt;Well done!&lt;/h4&gt;\n  &lt;span&gt;Nice message here&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>In <code>shard.yml</code>, add:</p> <pre><code>dependencies:\n  blueprint:\n    github: stephannv/blueprint\n</code></pre> <p>And run <code>shards install</code>.</p>"},{"location":"#why-use-blueprint","title":"Why use Blueprint?","text":"<p>The benefits of using Blueprint to build HTML templates:</p> <ul> <li> <p>Pure Crystal: One of the biggest benefits of using Crystal is its syntax, and using Blueprint you can take advantage of this syntax when building HTML.</p> </li> <li> <p>Oriented Object Programming: Blueprint makes it easy to create sustainable code, breaking web views in small pieces, encapsulating logic in its specialized views classes, following best practices principles, eg. Single responsability.</p> </li> <li> <p>Safety: All rendered content (eg. tags content and attributes values) are escaped by default.</p> </li> <li> <p>Fast enough &amp; Memory efficient: You can render significantly large views in nanoseconds or microseconds with a low memory footprint, depending on your machine's performance.</p> </li> <li> <p>Zero dependencies: Blueprint relies solely on the standard Crystal library.</p> </li> <li> <p>Phlex-friendly: If you're used to working with Phlex in Ruby, you'll find that Blueprint supports most of its syntax seamlessly.</p> </li> </ul>"},{"location":"#support","title":"Support","text":"<p>If you run into any trouble, please start a discussion, or open an issue if you  think you\u2019ve found a bug.</p>"},{"location":"#alternatives","title":"Alternatives","text":"<p>You can find Blueprint alternatives here:</p> <ul> <li>awesome-crystal</li> <li>shards.info</li> <li>shardsbox.org</li> </ul>"},{"location":"handbook/attributes/","title":"Attributes","text":""},{"location":"handbook/attributes/#overview","title":"Overview","text":"<p>HTML element methods (eg. <code>#h1</code>, <code>#meta</code>, <code>#div</code>, etc), accepts a NamedTuple as parameter, so it is possible to pass any attributes to an HTML element.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  private def blueprint\n    div x: 1, y: 2.5, foo: :bar do\n      input \"@blur\": \"doSomething\", v_model: \"user.name\"\n    end\n  end\nend\n\nputs Example.new.to_s\n</code></pre> <pre><code>&lt;div x=\"1\" y=\"1.2\" foo=\"bar\"&gt;\n  &lt;input @blur=\"doSomething\" v-model=\"user.name\"&gt;\n&lt;/div&gt;\n</code></pre> <p>Note that Blueprint parses all attributes name replacing <code>_</code> by <code>-</code>. So <code>v_model: \"name\"</code> will become <code>v-model=\"name\"</code>.</p>"},{"location":"handbook/attributes/#namedtuple-attributes","title":"NamedTuple attributes","text":"<p>If you pass a <code>NamedTuple</code> attribute to some element attribute, it will be flattened with a dash between each level. This is useful for <code>data-*</code> and <code>aria-*</code> attributes.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  private def blueprint\n    div data: { id: 42, target: \"#home\" }, aria: { selected: \"true\" } do\n      \"Home\"\n    end\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;div data-id=\"42\" data-target=\"#home\" aria-selected=\"true\"&gt;\n  Home\n&lt;/div&gt;\n</code></pre>"},{"location":"handbook/attributes/#boolean-attributes","title":"Boolean attributes","text":"<p>If you pass <code>true</code> to some attribute, it will be rendered as a boolean HTML attribute, in other words, just the attribute name will be rendered without the value. If you pass <code>false</code> the attribute will not be rendered. If you want the attribute value to be <code>\"true\"</code> or <code>\"false\"</code>, use <code>true</code> and <code>false</code> between quotes.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  private def blueprint\n    input required: true, disabled: false, x: \"true\", y: \"false\"\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;input required x=\"true\" y=\"false\"&gt;\n</code></pre>"},{"location":"handbook/attributes/#array-attributes","title":"Array attributes","text":"<p>If you pass an Array as attribute value, it will be flattened, compacted (<code>nil</code> values will be removed) and joined using <code>\" \"</code> as separator.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  private def blueprint\n    div class: [\"a\", \"b\", nil, [\"c\", \"d\"]] do\n      \"Hello\"\n    end\n  end\nend\n</code></pre> <p>Output:</p> <pre><code>&lt;div class=\"a b c d\"&gt;\n  Hello\n&lt;/div&gt;\n</code></pre>"},{"location":"handbook/builder/","title":"Builder","text":"<p><code>Blueprint::HTML</code> module provides the <code>.build</code> method for those cases when you don't need or don't want to create a class or struct to write HTML.</p> <pre><code>html = Blueprint::HTML.build do\n  h1 { \"Hello\" }\n  div do\n    span { \"World\" }\n  end\nend\n\nputs html\n</code></pre> <p>Output:</p> <pre><code>&lt;h1&gt;Hello&lt;/h1&gt;\n\n&lt;div&gt;\n  &lt;span&gt;World&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"handbook/code-style/","title":"Code style","text":"<p>If you are new to Crystal, know that blocks can be passed using <code>do ... end</code> or <code>{ ... }</code>. All of these are equivalent:</p> <pre><code># With `do ... end` blocks\nprivate def blueprint\n  html lang: \"pt-BR\" do\n    head do\n      title do\n        \"Blueprint\"\n      end\n    end\n\n    body do\n      h1 class: \"heading\" do\n        \"Hello World\"\n      end\n    end\n  end\nend\n\n# With `{ ... }` blocks\nprivate def blueprint\n  html lang: \"pt-BR\" {\n    head {\n      title {\n        \"Blueprint\"\n      }\n    }\n\n    body {\n      h1 class: \"heading\" {\n        \"Hello World\"\n      }\n    }\n  }\nend\n</code></pre> <p>It's a personal or team preference, you can stick to one style or mix two styles (eg. Use <code>do ... end</code> for multiline blocks and <code>{ ... }</code> for inline blocks). But note that in Crystal the difference between using <code>do ... end</code> and <code>{ ... }</code> is that <code>do ... end</code> binds to the left-most call, while <code>{ ... }</code> binds to the right-most call:</p> <p>With <code>do ... end</code> blocks: <pre><code>private def blueprint\n  render Alert.new do\n    \"Hello World\"\n  end\nend\n\n# The above is same as\nprivate def blueprint\n  render(Alert.new) do\n    \"Hello World\"\n  end\nend\n</code></pre></p> <p>While using <code>{ ... }</code> blocks: <pre><code>private def blueprint\n  render Alert.new {\n    \"Hello World\"\n  }\nend\n\n# The above is same as\nprivate def blueprint\n  render(Alert.new {\n    \"Hello World\"\n  })\nend\n</code></pre></p> <p>The example above will raise an error <code>Error: 'Alert.new' is not expected to be invoked with a block, but a block was given</code>, to fix this you need to add parentheses to <code>render</code> call when using with <code>{ ... }</code>.</p> <pre><code>private def blueprint\n  render(Alert.new) {\n    \"Hello World\"\n  }\nend\n</code></pre>"},{"location":"handbook/components/","title":"Components","text":""},{"location":"handbook/components/#overview","title":"Overview","text":"<p>Views vs. Components vs. Pages</p> <p>Please note that while these doc pages will use terms like views, pages and components to describe conceptual differences, in code all classes are implemented in the same way, there is no difference in practice. The <code>Blueprint::HTML</code> module must be included, which uses the <code>#blueprint</code> method to define an HTML structure, and <code>#render</code> method accepts any class that included <code>Blueprint::HTML</code> module.</p> <p>You can create reusable views using Blueprint, you just need to pass a component instance to the <code>#render</code> method.</p> <pre><code>class Alert\n  include Blueprint::HTML\n\n  def initialize(@content : String, @type : String); end\n\n  private def blueprint\n    div class: \"alert alert-#{@type}\", role: \"alert\" do\n      @content\n    end\n  end\nend\n\nclass Example\n  include Blueprint::HTML\n\n  private def blueprint\n    h1 { \"Hello\" }\n\n    render Alert.new(content: \"My alert\", type: \"primary\")\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;h1&gt;Hello&lt;/h1&gt;\n\n&lt;div class=\"alert alert-primary\" role=\"alert\"&gt;\n  My alert\n&lt;/div&gt;\n</code></pre>"},{"location":"handbook/components/#passing-content","title":"Passing Content","text":"<p>Sometimes you need to pass complex content that cannot be passed through a constructor parameter. To accomplish this, the component's <code>#blueprint</code> method needs to yield a block. Refactoring the previous Alert component example:</p> <pre><code>class Alert\n  include Blueprint::HTML\n\n  def initialize(@type : String); end\n\n  private def blueprint(&amp;)\n    div class: \"alert alert-#{@type}\", role: \"alert\" do\n      yield\n    end\n  end\nend\n\nclass Example\n  include Blueprint::HTML\n\n  private def blueprint\n    h1 { \"Hello\" }\n\n    render Alert.new(type: \"primary\") do\n      h4(class: \"alert-heading\") { \"My Alert\" }\n      p { \"Alert body\" }\n    end\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;h1&gt;Hello&lt;/h1&gt;\n\n&lt;div class=\"alert alert-primary\" role=\"alert\"&gt;\n  &lt;h4 class=\"alert-heading\"&gt;My alert&lt;/h4&gt;\n\n  &lt;p&gt;Alert body&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>Yielding blocks</p> <p>To define a method that receives a block, simply use yield inside it and the compiler will know. You can make this more explicit by declaring a dummy block parameter, indicated as a last parameter prefixed with ampersand (&amp;). eg. <pre><code>def blueprint(&amp;)\n  div { yield }\nend\n</code></pre></p>"},{"location":"handbook/components/#composing-components","title":"Composing Components","text":"<p>Blueprint components can expose some predefined structure to its users. This can be accomplished by defining public instance methods that can yield blocks or not. Refactoring the previous Alert component example:</p> <pre><code>class Alert\n  include Blueprint::HTML\n\n  def initialize(@type : String); end\n\n  private def blueprint(&amp;)\n    div class: \"alert alert-#{@type}\", role: \"alert\" do\n      yield\n    end\n  end\n\n  def title(&amp;)\n    h4(class: \"alert-heading\") { yield }\n  end\n\n  def body(&amp;)\n    p { yield }\n  end\nend\n\nclass Example\n  include Blueprint::HTML\n\n  private def blueprint\n    h1 { \"Hello\" }\n\n    render Alert.new(type: \"primary\") do |alert|\n      alert.title { \"My Alert\" }\n      alert.body { \"Alert body\" }\n    end\n  end\nend\n</code></pre> <p>Output:</p> <pre><code>&lt;h1&gt;Hello&lt;/h1&gt;\n\n&lt;div class=\"alert alert-primary\" role=\"alert\"&gt;\n  &lt;h4 class=\"alert-heading\"&gt;My alert&lt;/h4&gt;\n\n  &lt;p&gt;Alert body&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"handbook/conditional-rendering/","title":"Conditional Rendering","text":"<p>Blueprints objects can implement a <code>#render?</code> method, if this method returns false, the blueprint will not be rendered. This allows you extract the conditional logic from component consumer and put in the component itself.</p> <pre><code>class DraftAlertComponent\n  include Blueprint::HTML\n\n  def initialize(@article : Article); end\n\n  private def blueprint\n    div(class: \"alert alert-warning\") { \"This is a draft\" }\n  end\n\n  private def render?\n    @article.draft?\n  end\nend\n\nclass ArticlePage\n  include Blueprint::HTML\n\n  def initialize(@article: Article); end\n\n  private def blueprint\n    # Instead of writing:\n    # if @article.draft?\n    #   render DraftAlert.new(@article)\n    # end\n    render DraftAlertComponent.new(@article)\n\n    h1 { @article.title }\n  end\nend\n\narticle = Article.new(title: \"Hello Blueprint\", draft: false)\n\n# DraftAlert will not be rendered\nArticlePage.new(article: article).to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;h1&gt;Hello Blueprint&lt;/h1&gt;\n</code></pre>"},{"location":"handbook/elements/","title":"Elements","text":""},{"location":"handbook/elements/#overview","title":"Overview","text":"<p>All non-deprecated HTML elements are available as instance methods on Blueprint::HTML. The tag methods accept a NamedTuple, which are then converted into HTML attributes.</p> <pre><code>class Example\n  def blueprint\n    span { \"Hello!\" }\n\n    h1 class: \"heading\" do\n      \"Hello!\"\n    end\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output: <pre><code>&lt;span&gt;Hello!&lt;/span&gt;\n\n&lt;h1 class=\"heading\"&gt;Hello!&lt;/h1&gt;\n</code></pre></p>"},{"location":"handbook/elements/#standard-elements","title":"Standard elements","text":"<p>The avaiable element methods are:</p> <ul> <li> <p>Standard elements: <code>#a</code>, <code>#abbr</code>, <code>#address</code>, <code>#article</code>, <code>#aside</code>, <code>#audio</code>, <code>#b</code>, <code>#bdi</code>, <code>#bdo</code>, <code>#blockquote</code>, <code>#body</code>, <code>#button</code>, <code>#canvas</code>, <code>#caption</code>, <code>#cite</code>, <code>#code</code>, <code>#colgroup</code>, <code>#data</code>, <code>#datalist</code>, <code>#dd</code>, <code>#del</code>, <code>#details</code>, <code>#dfn</code>, <code>#dialog</code>, <code>#div</code>, <code>#dl</code>, <code>#dt</code>, <code>#em</code>, <code>#fieldset</code>, <code>#figcaption</code>, <code>#figure</code>, <code>#footer</code>, <code>#form</code>, <code>#h1</code>, <code>#h2</code>, <code>#h3</code>, <code>#h4</code>, <code>#h5</code>, <code>#h6</code>, <code>#head</code>, <code>#header</code>, <code>#hgroup</code>, <code>#html</code>, <code>#i</code>, <code>#ins</code>, <code>#kbd</code>, <code>#label</code>, <code>#legend</code>, <code>#li</code>, <code>#main</code>, <code>#map</code>, <code>#mark</code>, <code>#menu</code>, <code>#meter</code>, <code>#nav</code>, <code>#noscript</code>, <code>#object</code>, <code>#ol</code>, <code>#optgroup</code>, <code>#option</code>, <code>#output</code>, <code>#p</code>, <code>#picture</code>, <code>#pre</code>, <code>#progress</code>, <code>#q</code>, <code>#rp</code>, <code>#rt</code>, <code>#ruby</code>, <code>#s</code>, <code>#samp</code>, <code>#script</code>, <code>#section</code>, <code>#select_tag</code>, <code>#slot</code>, <code>#small</code>, <code>#span</code>, <code>#strong</code>, <code>#style</code>, <code>#sub</code>, <code>#summary</code>, <code>#sup</code>, <code>#table</code>, <code>#tbody</code>, <code>#td</code>, <code>#template</code>, <code>#textarea</code>, <code>#tfoot</code>, <code>#th</code>, <code>#thead</code>, <code>#time</code>, <code>#title</code>, <code>#tr</code>, <code>#u</code>, <code>#ul</code>, <code>#var</code>, <code>#video</code></p> </li> <li> <p>Empty and void elements: <code>#area</code>, <code>#base</code>, <code>#br</code>, <code>#col</code>, <code>#embed</code>, <code>#hr</code>, <code>#iframe</code>, <code>#img</code>, <code>#input</code>, <code>#link</code>, <code>#meta</code>, <code>#portal</code>, <code>#source</code>, <code>#track</code>, <code>#wbr</code></p> </li> </ul> <p>All standard elements accept content, but empty and void elements do not. However, you can still pass attributes to these elements.</p> <pre><code>class Example\n  def blueprint\n    iframe src: \"page.html\"\n\n    meta charset: \"utf-8\"\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output: <pre><code>&lt;iframe src=\"page.html\"&gt;&lt;/iframe&gt;\n\n&lt;meta charset=\"utf-8\"&gt;\n</code></pre></p>"},{"location":"handbook/elements/#custom-elements","title":"Custom elements","text":"<p>If you need to use a custom element, you can use the <code>#element</code> instance method.</p> <pre><code>class Example\n  def blueprint\n    element(\"v-btn\", to: \"home\") { \"Home\" }\n\n    element(\"QCard\", id: \"welcome-card\") { \"Hello World!\" }\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output: <pre><code>&lt;v-btn to=\"home\"&gt;Home&lt;/v-btn&gt;\n\n&lt;QCard id=\"welcome-card\"&gt;Hello World!&lt;QCard&gt;\n</code></pre></p> <p>If you frequently use a custom element, you can register it with the <code>register_element</code> macro for easier access.</p> <pre><code>class Example\n  register_element :v_btn\n  register_element :q_card, \"QCard\"\n\n  def blueprint\n    element(\"v-btn\", to: \"home\") { \"Home\" }\n\n    q_card(id: \"welcome-card\") { \"Hello World!\" }\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output: <pre><code>&lt;v-btn to=\"home\"&gt;Home&lt;/v-btn&gt;\n\n&lt;QCard id=\"welcome-card\"&gt;Hello World!&lt;QCard&gt;\n</code></pre></p> <p>It is also possible to use <code>register_void_element</code> and <code>register_empty_element</code> in case if you want elements without closing tags or elements that don't accept content.</p>"},{"location":"handbook/getting-started/","title":"Getting Started","text":""},{"location":"handbook/getting-started/#basic-usage","title":"Basic Usage","text":"<p>To start using Blueprint:</p> <ol> <li>Install Blueprint</li> <li>Require <code>\"blueprint/html\"</code></li> <li>Include <code>Blueprint::HTML</code> module in your class</li> <li>Define a <code>#blueprint</code> method to write the HTML structure inside</li> </ol> <pre><code>require \"blueprint/html\"\n\nclass Example\n  include Blueprint::HTML\n\n  private def blueprint\n    h1 { \"Hello World\" }\n  end\nend\n</code></pre> <p>To render your view class it's necessary to instantiate it and call <code>#to_s</code> method.</p> <pre><code>example = Example.new\nexample.to_s # =&gt; \"&lt;h1&gt;Hello World&lt;/h1&gt;\n</code></pre>"},{"location":"handbook/getting-started/#blueprinthtml-is-just-a-module","title":"<code>Blueprint::HTML</code> is just a module","text":"<p>The <code>Blueprint::HTML</code> module just add helper methods to handle the HTML building stuff and your class can have its own logic. For example, if you want pass data to your view object:</p> <pre><code>class ProfilePage\n  include Blueprint::HTML\n\n  def initialize(@user : User); end\n\n  private def blueprint\n    h1 { @user.name }\n\n    admin_badge if admin?\n  end\n\n  private def admin_badge\n    img src: \"admin-badge.png\"\n  end\n\n  private def admin?\n    @user.role == \"admin\"\n  end\nend\n\nuser = User.new(name: \"Jane Doe\", role: \"admin\")\npage = ProfilePage.new(user: user)\npage.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;h1&gt;Jane Doe&lt;/h1&gt;\n&lt;img src=\"admin-badge.png\"&gt;\n</code></pre> <p>It is possible even use structs instead of classes:</p> <pre><code>struct Card\n  include Blueprint::HTML\n\n  private def blueprint\n    div(class: \"card\") { \"Hello\" }\n  end\nend\n\n# or using `record` macro\nrecord Alert, message : String do\n  include Blueprint::HTML\n\n  private def blueprint\n    div(class: \"alert\") { @message }\n  end\nend\n\ncard = Card.new\ncard.to_s # =&gt; &lt;div class=\"card\"&gt;Hello&lt;/div&gt;\n\nalert = Alert.new(message: \"Hello\")\nalert.to_s # =&gt; &lt;div class=\"alert\"&gt;Hello&lt;/div&gt;\n</code></pre>"},{"location":"handbook/getting-started/#passing-content-to-views","title":"Passing content to views","text":"<p>If you want to pass content when rendering a view, you should define the <code>#blueprint(&amp;)</code> method and yield the block.</p> <pre><code>class Alert\n  include Blueprint::HTML\n\n  private def blueprint(&amp;)\n    div class: \"alert\" do\n      yield\n    end\n  end\nend\n\nalert = Alert.new\nalert.to_s { \"Hello World\" }\n</code></pre> <p>Output:</p> <pre><code>&lt;div class=\"alert\"&gt;\n  Hello World\n&lt;/div&gt;\n</code></pre>"},{"location":"handbook/helpers/","title":"Helpers","text":""},{"location":"handbook/helpers/#overview","title":"Overview","text":"<p>Blueprint provide some helper methods to help you build your HTML:</p>"},{"location":"handbook/helpers/#doctype","title":"<code>#doctype</code>","text":"<p>Adds HTML 5 doctype declaration.</p>"},{"location":"handbook/helpers/#plain","title":"<code>#plain</code>","text":"<p>Writes plain text on HTML without tags.</p>"},{"location":"handbook/helpers/#whitespace","title":"<code>#whitespace</code>","text":"<p>Adds a simple whitespace to HTML.</p>"},{"location":"handbook/helpers/#comment","title":"<code>#comment</code>","text":"<p>Allows writing HTML comments.</p>"},{"location":"handbook/helpers/#raw","title":"<code>#raw</code>","text":"<p>Write content without escaping. You must pass a <code>Blueprint::SafeObject</code> to this method. Learn more about this at Safety section. WARNING: This must be used with great caution. You should avoid using this method with any content that originates from an untrusted source (eg. people on internet).</p>"},{"location":"handbook/helpers/#examples","title":"Examples","text":"<pre><code>class ExamplePage\n  include Blueprint::HTML\n\n  private def blueprint\n    doctype\n\n    comment \"This is a comment\"\n\n    h1 do\n      plain \"Welcome\"\n      whitespace\n      strong { \"Jane Doe\" }\n    end\n\n    raw safe(\"&lt;script&gt;alert('Nice Script!')&lt;/script&gt;\")\n  end\nend\n\nExamplePage.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;!DOCTYPE html&gt;\n\n&lt;!--This is a comment--&gt;\n\n&lt;h1&gt;\n  Welcome &lt;strong&gt;Jane Doe&lt;/strong&gt;\n&lt;/h1&gt;\n\n&lt;script&gt;alert('Nice Script!')&lt;/script&gt;\n</code></pre>"},{"location":"handbook/safety/","title":"Safety","text":""},{"location":"handbook/safety/#overview","title":"Overview","text":"<p>When using Blueprint all content and attribute values passed to elements and components are escaped by default.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  private def blueprint\n    plain \"&lt;script&gt;alert('DANGER!')&lt;/script&gt;\"\n\n    comment \"--&gt;&lt;script&gt;alert('DANGER!')&lt;/script&gt;&lt;!--\"\n\n    span { \"&lt;script&gt;alert('DANGER!')&lt;/script&gt;\" }\n\n    input(class: \"some-class\\\" onblur=\\\"alert('DANGER!')\")\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&amp;lt;script&amp;gt;alert(&amp;#39;DANGER!&amp;#39;)&amp;lt;/script&amp;gt;\n\n&lt;!----&amp;gt;&amp;lt;script&amp;gt;alert(&amp;#39;DANGER!&amp;#39;)&amp;lt;/script&amp;gt;&amp;lt;!----&gt;\n\n&lt;span&gt;&amp;lt;script&amp;gt;alert(&amp;#39;DANGER!&amp;#39;)&amp;lt;/script&amp;gt;&lt;/span&gt;\n\n&lt;input class=\"some-class&amp;quot; onblur=&amp;quot;alert('DANGER!')\"&gt;\n</code></pre> <p>Escaping</p> <p>Blueprint escapes attribute values replacing <code>\"</code> by <code>&amp;quot;</code>, and escapes content using the Crystal native <code>HTML.escape</code>. If you find any issues related to this behavior, please report them on Blueprint repository.</p>"},{"location":"handbook/safety/#bypassing-safety","title":"Bypassing safety","text":"<p>To bypass escaping, you can use the <code>#raw</code> and <code>#safe</code> methods. The <code>#raw</code> method appends content to buffer without escaping, while the <code>#safe</code> method wraps the given object in a <code>Blueprint::SafeValue</code>, indicating to Blueprint that the content should be rendered without escaping.</p> <p>WARNING: This must be used with great caution. You should avoid using this method with any content that originates from an untrusted source (eg. people on internet).</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  private def blueprint\n    div { safe(\"&lt;script&gt;alert('Nice Script!')&lt;/script&gt;\") }\n\n    iframe srcdoc: safe(\"&lt;div&gt;Safe Content&lt;/div&gt;\")\n\n    raw safe(\"&lt;script&gt;alert('Another Nice Script!')&lt;/script&gt;\")\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output</p> <pre><code>&lt;div&gt;\n  &lt;script&gt;alert('Nice Script!')&lt;/script&gt;\n&lt;/div&gt;\n\n&lt;iframe srcdoc=\"&lt;div&gt;Safe Content&lt;/div&gt;\"&gt;&lt;/iframe&gt;\n\n&lt;script&gt;alert('Another Nice Script!')&lt;/script&gt;\n</code></pre>"},{"location":"handbook/svg/","title":"SVG","text":"<p>Blueprint supports building SVG tags.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  private def blueprint\n    svg xmlns: \"http://www.w3.org/2000/svg\", width: 30, height: 10 do\n      g fill: :red do\n        rect x: 0, y: 0, width: 10, height: 10\n        rect x: 20, y: 0, width: 10, height: 10\n      end\n    end\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"30\" height=\"10\"&gt;\n  &lt;g fill=\"red\"&gt;\n    &lt;rect x=\"0\" y=\"0\" width=\"10\" height=\"10\"&gt;&lt;/rect&gt;\n    &lt;rect x=\"20\" y=\"0\" width=\"10\" height=\"10\"&gt;&lt;/rect&gt;\n  &lt;/g&gt;\n&lt;/svg&gt;\n</code></pre> <p>You should note that SVG tags methods are accessible only inside <code>#svg</code> method block, using a SVG tag outside SVG block will result in a compilation error.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  private def blueprint\n    svg do\n      path d: \"M3.75 9h16.5m-16.5 6.75h16.5\" # OK\n    end\n\n    # Error: undefined local variable or method 'path' for Example\n    path d: \"M3.75 9h16.5m-16.5 6.75h16.5\"\n  end\nend\n</code></pre> <p>The available SVG tags are: <code>a</code>, <code>animate</code>, <code>animateMotion</code>, <code>animateTransform</code>, <code>circle</code>, <code>clipPath</code>, <code>defs</code>, <code>desc</code>, <code>discard</code>, <code>ellipse</code>, <code>feBlend</code>, <code>feColorMatrix</code>, <code>feComponentTransfer</code>, <code>feComposite</code>, <code>feConvolveMatrix</code>, <code>feDiffuseLighting</code>, <code>feDisplacementMap</code>, <code>feDistantLight</code>, <code>feDropShadow</code>, <code>feFlood</code>, <code>feFuncA</code>, <code>feFuncB</code>, <code>feFuncG</code>, <code>feFuncR</code>, <code>feGaussianBlur</code>, <code>feImage</code>, <code>feMerge</code>, <code>feMergeNode</code>, <code>feMorphology</code>, <code>feOffset</code>, <code>fePointLight</code>, <code>feSpecularLighting</code>, <code>feSpotLight</code>, <code>feTile</code>, <code>feTurbulence</code>, <code>filter</code>, <code>foreignObject</code>, <code>g</code>, <code>image</code>, <code>line</code>, <code>linearGradient</code>, <code>marker</code>, <code>mask</code>, <code>metadata</code>, <code>mpath</code>, <code>path</code>, <code>pattern</code>, <code>polygon</code>, <code>polyline</code>, <code>radialGradient</code>, <code>rect</code>, <code>script</code>, <code>set</code>, <code>stop</code>, <code>style</code>, <code>svg</code>, <code>switch</code>, <code>symbol</code>, <code>text</code>, <code>textPath</code>, <code>title</code>, <code>tspan</code>, <code>use</code>, <code>view</code>.</p>"},{"location":"handbook/utils/","title":"Utils","text":""},{"location":"handbook/utils/#overview","title":"Overview","text":"<p>Blueprint provide some helper methods to help you build your HTML.</p> <p>Utils vs Helpers</p> <p>The key difference between the utility methods described here and the helper methods described in Helpers is that helper methods append content to the buffer, while utility methods just return values without appending anything to the buffer.</p>"},{"location":"handbook/utils/#safe","title":"<code>#safe</code>","text":"<p>Wraps the given object in a <code>Blueprint::SafeValue</code>, indicating to Blueprint that the content should be rendered without escaping. Learn more about this at Safety.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  def blueprint\n    div { \"&lt;script&gt;Nice script!&lt;/script&gt;\" }\n\n    div { safe(\"&lt;script&gt;Nice script!&lt;/script&gt;\") }\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;&amp;lt;script&amp;gt;Nice script!&amp;lt;/script&amp;gt;&lt;/div&gt;\n\n&lt;div&gt;&lt;script&gt;Nice script!&lt;/script&gt;&lt;/div&gt;\n</code></pre>"},{"location":"handbook/utils/#escape_once","title":"<code>#escape_once</code>","text":"<p>Returns an escaped version of given content without affecting existing escaped entities.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  def blueprint\n    div { escape_once(\"1 &lt; 2 &amp;amp; 3\") }\n\n    div { escape_once(\"&amp;lt;&amp;lt; Accept &amp; Checkout\") }\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;div&gt;1 &amp;lt; 2 &amp;amp; 3&lt;/div&gt;\n\n&lt;div&gt;&amp;lt;&amp;lt; Accept &amp;amp; Checkout&lt;/div&gt;\n</code></pre>"},{"location":"handbook/wrapping/","title":"Wrapping","text":"<p>By overriding the <code>#around_render</code> method, you can create a wrapper around your view content. This is useful when defining layouts for pages, for example. Don't forget to yield a block inside <code>#around_render</code> method.</p> <pre><code>class Example\n  include Blueprint::HTML\n\n  private def blueprint\n    h1 { \"Home\" }\n  end\n\n  private def around_render(&amp;)\n    html do\n      body do\n        yield\n      end\n    end\n  end\nend\n\nExample.new.to_s\n</code></pre> <p>Output:</p> <pre><code>&lt;html&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Home&lt;/h1&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>With <code>#around_render</code> method you can create some flexible layouts for your pages. For example, you can use inheritance to have multiple layouts on your application.</p> <pre><code>class MainLayout\n  include Blueprint::HTML\n\n  private def around_render(&amp;)\n    html do\n      body do\n        div class: \"main-layout\" do\n          yield\n        end\n      end\n    end\n  end\nend\n\nclass AuthLayout\n  include Blueprint::HTML\n\n  private def around_render(&amp;)\n    html do\n      body do\n        div class: \"auth-layout\" do\n          yield\n        end\n      end\n    end\n  end\nend\n\nclass HomePage &lt; MainLayout\n  private def blueprint\n    h1 { \"Welcome\" }\n  end\nend\n\nclass LoginPage &lt; AuthLayout\n  private def blueprint\n    h1 { \"Sign In\" }\n  end\nend\n\nHomePage.new.to_s\n\nLoginPage.new.to_s\n</code></pre> <p>HomePage output:</p> <pre><code>&lt;html&gt;\n  &lt;body&gt;\n    &lt;div class=\"main-layout\"&gt;\n      &lt;h1&gt;Welcome&lt;/h1&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>LoginPage output:</p> <pre><code>&lt;html&gt;\n  &lt;body&gt;\n    &lt;div class=\"auth-layout\"&gt;\n      &lt;h1&gt;Sign In&lt;/h1&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"}]}